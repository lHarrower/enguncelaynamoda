// AYNA Mirror Authentication Integration Tests
import React from 'react';
import { render, waitFor, cleanup } from '@testing-library/react-native';
import { View, Text } from 'react-native';
import { AuthProvider, useAuth } from '@/context/AuthContext';
import { ThemeProvider } from '@/theme/ThemeProvider';
import AynaMirrorPage from '@/app/(app)/ayna-mirror';
import AynaMirrorSettingsPage from '@/app/ayna-mirror-settings';
import { mocks } from '@/__tests__/mocks';
const mockAuth = mocks.supabase.auth;

// Mock Supabase is handled by the shared mock file

// Mock expo-router
jest.mock('expo-router', () => {
  const React = require('react');
  const { View, Text } = require('react-native');
  
  return {
    router: {
      push: jest.fn(),
      back: jest.fn(),
      replace: jest.fn(),
    },
    useLocalSearchParams: jest.fn(() => ({})),
    Redirect: ({ href }: { href: string }) => {
      // Simulate the actual Redirect behavior for testing
      React.useEffect(() => {
        // In real app, this would navigate
        console.log('Redirecting to:', href);
      }, [href]);
      
      return React.createElement(View, { testID: 'redirect' },
        React.createElement(Text, { testID: 'redirect-href' }, href)
      );
    },
  };
});

// Mock AYNA Mirror screens
jest.mock('@/screens/AynaMirrorScreen', () => {
  const React = require('react');
  const { View, Text } = require('react-native');
  
  return {
    AynaMirrorScreen: ({ userId }: { userId: string }) => (
      React.createElement(View, { testID: 'ayna-mirror-screen' },
        React.createElement(Text, { testID: 'user-id' }, userId)
      )
    ),
  };
});

jest.mock('@/screens/AynaMirrorSettingsScreen', () => {
  const React = require('react');
  const { View, Text } = require('react-native');
  
  return {
    __esModule: true,
    default: ({ navigation }: { navigation: any }) => (
      React.createElement(View, { testID: 'ayna-mirror-settings-screen' },
        React.createElement(Text, null, 'AYNA Mirror Settings')
      )
    ),
  };
});

// Mock services
jest.mock('@/services/notificationHandler', () => ({
  __esModule: true,
  default: {
    initialize: jest.fn(),
    cleanup: jest.fn(),
    isReady: jest.fn(() => true),
  },
}));

// Test wrapper component
const TestWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (
  <ThemeProvider>
    <AuthProvider>{children}</AuthProvider>
  </ThemeProvider>
);

describe('AYNA Mirror Authentication Integration', () => {
  // Use the mockAuth from the shared mock

  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    cleanup();
  });

  describe('Authenticated User Flow', () => {
    beforeEach(() => {
      // Reset to default authenticated state
      mockAuth.getSession.mockResolvedValue({
        data: {
          session: {
            user: {
              id: 'authenticated-user-123',
              email: 'test@example.com',
              created_at: new Date().toISOString(),
            },
            access_token: 'mock-token',
            refresh_token: 'mock-refresh-token',
            expires_at: Date.now() + 3600000,
          },
        },
        error: null,
      } as any);

      // Override auth state change for authenticated flow
      mockAuth.onAuthStateChange.mockImplementation((callback: any) => {
        // Simulate authenticated state after getSession completes
        setTimeout(() => {
          callback('SIGNED_IN', {
            user: {
              id: 'authenticated-user-123',
              email: 'test@example.com',
              created_at: new Date().toISOString(),
            },
            access_token: 'mock-token',
            refresh_token: 'mock-refresh-token',
            expires_at: Date.now() + 3600000,
          });
        }, 10); // Small delay to allow getSession to complete first

        return {
          data: { subscription: { unsubscribe: jest.fn() } },
        };
      });
    });

    it('should render AYNA Mirror screen for authenticated user', async () => {
      const { getByTestId } = render(
        <TestWrapper>
          <AynaMirrorPage />
        </TestWrapper>,
      );

      await waitFor(() => {
        const aynaMirrorScreen = getByTestId('ayna-mirror-screen');
        expect(aynaMirrorScreen).toBeTruthy();
        const userIdText = getByTestId('user-id');
        expect(userIdText.props.children).toBe('authenticated-user-123');
      });
    });

    it('should render AYNA Mirror settings for authenticated user', async () => {
      const { getByTestId } = render(
        <TestWrapper>
          <AynaMirrorSettingsPage />
        </TestWrapper>,
      );

      await waitFor(() => {
        const settingsScreen = getByTestId('ayna-mirror-settings-screen');
        expect(settingsScreen).toBeTruthy();
      });
    });

    it('should pass correct user ID to AYNA Mirror screen', async () => {
      const { getByTestId } = render(
        <TestWrapper>
          <AynaMirrorPage />
        </TestWrapper>,
      );

      await waitFor(() => {
        const userIdText = getByTestId('user-id');
        expect(userIdText.props.children).toBe('authenticated-user-123');
      });
    });
  });

  describe('Unauthenticated User Flow', () => {
    beforeEach(() => {
      // Mock no session
      mockAuth.getSession.mockResolvedValue({
        data: { session: null },
        error: null,
      } as any);

      // Mock auth state change listener for unauthenticated state
      mockAuth.onAuthStateChange.mockImplementation((callback: any) => {
        // Simulate the auth state change after getSession completes
        setTimeout(() => {
          callback('SIGNED_OUT', null);
        }, 10); // Small delay to allow getSession to complete first

        return {
          data: { subscription: { unsubscribe: jest.fn() } },
        };
      });
    });

    it('should redirect to sign-in when user is not authenticated', async () => {
      const { getByTestId } = render(
        <TestWrapper>
          <AynaMirrorPage />
        </TestWrapper>,
      );

      await waitFor(() => {
        const redirect = getByTestId('redirect');
        expect(redirect).toBeTruthy();
        expect(redirect.props['data-href']).toBe('/auth/sign-in');
      });
    });

    it('should redirect settings page to sign-in when user is not authenticated', async () => {
      const { getByTestId } = render(
        <TestWrapper>
          <AynaMirrorSettingsPage />
        </TestWrapper>,
      );

      await waitFor(() => {
        const redirect = getByTestId('redirect');
        expect(redirect).toBeTruthy();
        expect(redirect.props['data-href']).toBe('/auth/sign-in');
      });
    });
  });

  describe('Loading States', () => {
    beforeEach(() => {
      // Mock loading state - session call takes time
      mockAuth.getSession.mockImplementation(
        () =>
          new Promise((resolve) => {
            setTimeout(() => {
              resolve({
                data: { session: null },
                error: null,
              } as any);
            }, 100); // Reduced timeout for faster tests
          }),
      );
      
      // Mock auth state change for loading test
      mockAuth.onAuthStateChange.mockImplementation((callback: any) => {
        setTimeout(() => {
          callback('SIGNED_OUT', null);
        }, 150); // After getSession completes
        return {
          data: { subscription: { unsubscribe: jest.fn() } },
        };
      });
    });

    it('should show loading state while authentication is being determined', async () => {
      const { queryByTestId } = render(
        <TestWrapper>
          <AynaMirrorPage />
        </TestWrapper>,
      );

      // Should not show redirect immediately while loading
      expect(queryByTestId('redirect')).toBeNull();
      expect(queryByTestId('ayna-mirror-screen')).toBeNull();

      // After loading completes, should redirect
      await waitFor(
        () => {
          expect(queryByTestId('redirect')).toBeTruthy();
        },
        { timeout: 500 }, // Reduced timeout to match mock timing
      );
    });
  });

  describe('Authentication State Changes', () => {
    it('should handle sign-in during app usage', async () => {
      let authCallback: any;

      // Start with unauthenticated state
      mockAuth.getSession.mockResolvedValue({
        data: { session: null },
        error: null,
      } as any);

      mockAuth.onAuthStateChange.mockImplementation((callback: any) => {
        authCallback = callback;
        // Initial state callback
        setTimeout(() => {
          callback('SIGNED_OUT', null);
        }, 10);
        return {
          data: { subscription: { unsubscribe: jest.fn() } },
        };
      });

      const { getByTestId, rerender } = render(
        <TestWrapper>
          <AynaMirrorPage />
        </TestWrapper>,
      );

      // Should initially redirect to sign-in
      await waitFor(() => {
        expect(getByTestId('redirect').props['data-href']).toBe('/auth/sign-in');
      });

      // Simulate user signing in
      authCallback('SIGNED_IN', {
        user: {
          id: 'newly-signed-in-user',
          email: 'newuser@example.com',
        },
        access_token: 'new-token',
        refresh_token: 'new-refresh-token',
      });

      // Re-render to reflect auth state change
      rerender(
        <TestWrapper>
          <AynaMirrorPage />
        </TestWrapper>,
      );

      // Should now show AYNA Mirror screen
      await waitFor(() => {
        const aynaMirrorScreen = getByTestId('ayna-mirror-screen');
        expect(aynaMirrorScreen).toBeTruthy();
        expect(aynaMirrorScreen.props['data-user-id']).toBe('newly-signed-in-user');
      });
    });

    it('should handle sign-out during app usage', async () => {
      let authCallback: any;

      // Start with authenticated state
      mockAuth.getSession.mockResolvedValue({
        data: {
          session: {
            user: {
              id: 'signed-in-user',
              email: 'user@example.com',
            },
            access_token: 'token',
            refresh_token: 'refresh-token',
          },
        },
        error: null,
      } as any);

      mockAuth.onAuthStateChange.mockImplementation((callback: any) => {
        authCallback = callback;
        // Initial authenticated state callback
        setTimeout(() => {
          callback('SIGNED_IN', {
            user: {
              id: 'signed-in-user',
              email: 'user@example.com',
            },
            access_token: 'token',
            refresh_token: 'refresh-token',
          });
        }, 10);
        return {
          data: { subscription: { unsubscribe: jest.fn() } },
        };
      });

      const { getByTestId, rerender } = render(
        <TestWrapper>
          <AynaMirrorPage />
        </TestWrapper>,
      );

      // Should initially show AYNA Mirror screen
      await waitFor(() => {
        const aynaMirrorScreen = getByTestId('ayna-mirror-screen');
        expect(aynaMirrorScreen).toBeTruthy();
      });

      // Simulate user signing out
      authCallback('SIGNED_OUT', null);

      // Re-render to reflect auth state change
      rerender(
        <TestWrapper>
          <AynaMirrorPage />
        </TestWrapper>,
      );

      // Should now redirect to sign-in
      await waitFor(() => {
        const redirect = getByTestId('redirect');
        expect(redirect.props['data-href']).toBe('/auth/sign-in');
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle authentication errors gracefully', async () => {
      // Mock authentication error
      mockAuth.getSession.mockRejectedValue(new Error('Auth error'));
      
      // Mock auth state change for error case
      mockAuth.onAuthStateChange.mockImplementation((callback: any) => {
        setTimeout(() => {
          callback('SIGNED_OUT', null);
        }, 10);
        return {
          data: { subscription: { unsubscribe: jest.fn() } },
        };
      });

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      const { queryByTestId } = render(
        <TestWrapper>
          <AynaMirrorPage />
        </TestWrapper>,
      );

      await waitFor(() => {
        // Should handle error gracefully and not crash
        expect(queryByTestId('redirect')).toBeTruthy();
      });

      consoleSpy.mockRestore();
    });

    it('should handle session parsing errors', async () => {
      // Mock malformed session response
      mockAuth.getSession.mockResolvedValue({
        data: { session: null },
        error: { message: 'Session parsing error' },
      });

      mockAuth.onAuthStateChange.mockImplementation((callback: any) => {
        // Immediately trigger SIGNED_OUT state
        callback('SIGNED_OUT', null);
        return {
          data: { subscription: { unsubscribe: jest.fn() } },
        };
      });

      const { queryByTestId, getByTestId } = render(
        <TestWrapper>
          <AynaMirrorPage />
        </TestWrapper>,
      );

      // Should handle gracefully and redirect
      await waitFor(() => {
        const redirectElement = queryByTestId('redirect');
        expect(redirectElement).toBeTruthy();
      }, { timeout: 3000 });
    });
  });

  describe('Context Integration', () => {
    it('should properly integrate with AuthContext', async () => {
      // Create a test component that uses useAuth
      const TestComponent = () => {
        const { user, session, loading } = useAuth();
        const [mounted, setMounted] = React.useState(true);

        React.useEffect(() => {
          return () => {
            setMounted(false);
          };
        }, []);

        if (!mounted) {
          return null;
        }

        return React.createElement(View, { testID: 'auth-state' },
          React.createElement(Text, { testID: 'user-id' }, user?.id || 'no-user'),
          React.createElement(Text, { testID: 'session-status' }, session ? 'has-session' : 'no-session'),
          React.createElement(Text, { testID: 'loading-status' }, loading ? 'loading' : 'loaded')
        );
      };

      mockAuth.getSession.mockResolvedValue({
        data: {
          session: {
            user: {
              id: 'context-test-user',
              email: 'context@test.com',
              created_at: new Date().toISOString(),
            },
            access_token: 'token',
            refresh_token: 'refresh-token',
            expires_at: Date.now() + 3600000,
          },
        },
        error: null,
      });

      mockAuth.onAuthStateChange.mockImplementation((callback: any) => {
        setTimeout(() => {
          callback('SIGNED_IN', {
            user: {
              id: 'context-test-user',
              email: 'context@test.com',
            },
            access_token: 'token',
            refresh_token: 'refresh-token',
            expires_at: Date.now() + 3600000,
          });
        }, 10); // Small delay to allow getSession to complete first
        return {
          data: { subscription: { unsubscribe: jest.fn() } },
        };
      });

      const renderResult = render(
        <TestWrapper>
          <TestComponent />
        </TestWrapper>,
      );

      try {
        await waitFor(() => {
          expect(renderResult.getByTestId('user-id')).toBeTruthy();
          expect(renderResult.getByTestId('session-status')).toBeTruthy();
          expect(renderResult.getByTestId('loading-status')).toBeTruthy();
        }, { timeout: 1000 });
      } finally {
        // Cleanup - wait a bit before unmounting to avoid race conditions
        await new Promise(resolve => setTimeout(resolve, 100));
        renderResult.unmount();
      }
    });
  });
});
