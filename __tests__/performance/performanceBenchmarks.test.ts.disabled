/**
 * Performance Benchmark Tests for AYNA Mirror System
 * Tests response times and performance characteristics
 */

// Mock external dependencies first
jest.mock('@/config/supabaseClient', () => ({
  supabase: {
    from: jest.fn(),
    auth: {
      getUser: jest.fn(),
    },
  },
}));
jest.mock('@/services/weatherService');

import { aynaMirrorService } from '@/services/aynaMirrorService';
import { intelligenceService } from '@/services/intelligenceService';
import { enhancedWardrobeService } from '@/services/enhancedWardrobeService';
import { weatherService } from '@/services/weatherService';
import notificationService from '@/services/notificationService';
import { supabase } from '@/config/supabaseClient';

describe('Performance Benchmarks - AYNA Mirror System', () => {
  const mockUserId = 'performance-test-user';
  const mockDate = new Date('2024-01-15T06:00:00Z');

  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();
    jest.setSystemTime(mockDate);
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe('Core Performance Benchmarks', () => {
    it('should generate daily recommendations in under 1 second', async () => {
      // Setup realistic mock data
      const mockWardrobeItems = Array.from({ length: 50 }, (_, i) => ({
        id: `item-${i}`,
        userId: mockUserId,
        category: ['tops', 'bottoms', 'shoes', 'outerwear'][i % 4],
        colors: ['red', 'blue', 'green', 'black', 'white'][i % 5],
        tags: ['casual', 'formal', 'work', 'weekend'][i % 4],
        usageStats: {
          totalWears: Math.floor(Math.random() * 20),
          lastWorn: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000),
          averageRating: 3 + Math.random() * 2,
        },
      }));

      const mockWeatherContext = {
        temperature: 22,
        condition: 'sunny' as const,
        humidity: 45,
        location: 'San Francisco',
        timestamp: mockDate,
      };

      // Mock service responses with realistic delays
      jest
        .spyOn(weatherService as any, 'getCurrentWeatherContext')
        .mockImplementation(
          () => new Promise((resolve) => setTimeout(() => resolve(mockWeatherContext), 50)),
        );

      (supabase.from as jest.Mock).mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockImplementation(
            () =>
              new Promise((resolve) =>
                setTimeout(
                  () =>
                    resolve({
                      data: mockWardrobeItems,
                      error: null,
                    }),
                  100,
                ),
              ),
          ),
        }),
        insert: jest.fn().mockReturnValue({
          data: { id: 'recommendation-perf' },
          error: null,
        }),
      });

      // Measure performance
      const startTime = performance.now();
      const recommendations = await aynaMirrorService.generateDailyRecommendations(mockUserId);
      const endTime = performance.now();
      const duration = endTime - startTime;

      // Performance assertions
      expect(duration).toBeLessThan(1000); // Under 1 second
      expect(recommendations).toBeDefined();
      expect(recommendations.recommendations).toHaveLength(3);

      console.log(`Daily recommendations generated in ${duration.toFixed(2)}ms`);
    });

    it('should process user feedback in under 500ms', async () => {
      const mockFeedback = {
        id: 'feedback-perf',
        outfitRecommendationId: 'outfit-perf-test',
        userId: mockUserId,
        confidenceRating: 4,
        emotionalResponse: {
          primary: 'confident' as const,
          intensity: 8,
          additionalEmotions: ['stylish'],
        },
        socialFeedback: {
          complimentsReceived: 2,
          positiveReactions: ['like', 'heart'],
          socialContext: 'friends',
        },
        occasion: 'casual',
        comfort: { physical: 4, emotional: 4, confidence: 4 },
        timestamp: mockDate,
      };

      // Mock database operations with realistic delays
      (supabase.from as jest.Mock).mockReturnValue({
        insert: jest.fn().mockImplementation(
          () =>
            new Promise((resolve) =>
              setTimeout(
                () =>
                  resolve({
                    data: { id: 'feedback-perf' },
                    error: null,
                  }),
                50,
              ),
            ),
        ),
        update: jest.fn().mockReturnValue({
          eq: jest.fn().mockImplementation(
            () =>
              new Promise((resolve) =>
                setTimeout(
                  () =>
                    resolve({
                      data: {},
                      error: null,
                    }),
                  30,
                ),
              ),
          ),
        }),
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockImplementation(
            () =>
              new Promise((resolve) =>
                setTimeout(
                  () =>
                    resolve({
                      data: [mockFeedback],
                      error: null,
                    }),
                  40,
                ),
              ),
          ),
        }),
      });

      // Measure performance
      const startTime = performance.now();
      await aynaMirrorService.processUserFeedback(mockFeedback);
      const endTime = performance.now();
      const duration = endTime - startTime;

      // Performance assertions
      expect(duration).toBeLessThan(500); // Under 500ms
      console.log(`Feedback processed in ${duration.toFixed(2)}ms`);
    });

    it('should handle large wardrobes efficiently', async () => {
      // Create a large wardrobe (200 items)
      const largeWardrobe = Array.from({ length: 200 }, (_, i) => ({
        id: `large-item-${i}`,
        userId: mockUserId,
        category: ['tops', 'bottoms', 'shoes', 'outerwear', 'accessories'][i % 5],
        colors: ['red', 'blue', 'green', 'black', 'white', 'grey', 'brown'][i % 7],
        tags: ['casual', 'formal', 'work', 'weekend', 'party', 'sport'][i % 6],
        usageStats: {
          totalWears: Math.floor(Math.random() * 30),
          lastWorn: new Date(Date.now() - Math.random() * 60 * 24 * 60 * 60 * 1000),
          averageRating: 2 + Math.random() * 3,
        },
      }));

      (supabase.from as jest.Mock).mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            data: largeWardrobe,
            error: null,
          }),
        }),
        insert: jest.fn().mockReturnValue({
          data: { id: 'recommendation-large' },
          error: null,
        }),
      });

      (weatherService.getCurrentWeather as jest.Mock).mockResolvedValue({
        temperature: 20,
        condition: 'cloudy' as const,
        humidity: 60,
        location: 'Test City',
        timestamp: mockDate,
      });

      // Measure performance with large dataset
      const startTime = performance.now();
      const recommendations = await aynaMirrorService.generateDailyRecommendations(mockUserId);
      const endTime = performance.now();
      const duration = endTime - startTime;

      // Should still be fast with large wardrobe
      expect(duration).toBeLessThan(2000); // Under 2 seconds even with 200 items
      expect(recommendations.recommendations).toHaveLength(3);
      console.log(`Large wardrobe (200 items) processed in ${duration.toFixed(2)}ms`);
    });
  });

  describe('Service-Specific Performance', () => {
    it('should analyze user style profile efficiently', async () => {
      const mockFeedbackHistory = Array.from({ length: 100 }, (_, i) => ({
        outfitId: `outfit-${i}`,
        confidenceRating: 2 + Math.random() * 3,
        emotionalResponse: {
          primary: ['confident', 'comfortable', 'stylish'][i % 3],
          intensity: 5 + Math.random() * 5,
        },
        timestamp: new Date(Date.now() - i * 24 * 60 * 60 * 1000),
      }));

      (supabase.from as jest.Mock).mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            data: mockFeedbackHistory,
            error: null,
          }),
        }),
      });

      const startTime = performance.now();
      const styleProfile = await intelligenceService.analyzeUserStyleProfile(mockUserId);
      const endTime = performance.now();
      const duration = endTime - startTime;

      expect(duration).toBeLessThan(300); // Under 300ms
      expect(styleProfile).toBeDefined();
      console.log(`Style profile analysis completed in ${duration.toFixed(2)}ms`);
    });

    it('should calculate outfit compatibility quickly', async () => {
      const mockItems = [
        { id: 'item-1', category: 'tops', colors: ['blue'], tags: ['casual'] },
        { id: 'item-2', category: 'bottoms', colors: ['black'], tags: ['formal'] },
        { id: 'item-3', category: 'shoes', colors: ['brown'], tags: ['casual'] },
      ];

      const startTime = performance.now();
      const compatibilityScore = await intelligenceService.calculateOutfitCompatibility(
        mockItems as any,
      );
      const endTime = performance.now();
      const duration = endTime - startTime;

      expect(duration).toBeLessThan(100); // Under 100ms
      expect(compatibilityScore).toBeGreaterThanOrEqual(0);
      expect(compatibilityScore).toBeLessThanOrEqual(5);
      console.log(`Outfit compatibility calculated in ${duration.toFixed(2)}ms`);
    });

    it('should track item usage efficiently', async () => {
      (supabase.from as jest.Mock).mockReturnValue({
        update: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            data: {},
            error: null,
          }),
        }),
      });

      const startTime = performance.now();
      await enhancedWardrobeService.trackItemUsage('test-item-id', 'test-outfit-id');
      const endTime = performance.now();
      const duration = endTime - startTime;

      expect(duration).toBeLessThan(50); // Under 50ms
      console.log(`Item usage tracked in ${duration.toFixed(2)}ms`);
    });
  });

  describe('Concurrent Operations Performance', () => {
    it('should handle multiple simultaneous recommendation requests', async () => {
      const userIds = Array.from({ length: 10 }, (_, i) => `concurrent-user-${i}`);

      // Mock responses for all users
      (supabase.from as jest.Mock).mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            data: [
              { id: 'item-1', category: 'tops', colors: ['blue'] },
              { id: 'item-2', category: 'bottoms', colors: ['black'] },
            ],
            error: null,
          }),
        }),
        insert: jest.fn().mockReturnValue({
          data: { id: 'concurrent-recommendation' },
          error: null,
        }),
      });

      (weatherService.getCurrentWeather as jest.Mock).mockResolvedValue({
        temperature: 20,
        condition: 'sunny' as const,
        humidity: 50,
        location: 'Test City',
        timestamp: mockDate,
      });

      const startTime = performance.now();

      // Execute concurrent requests
      const promises = userIds.map((userId) =>
        aynaMirrorService.generateDailyRecommendations(userId),
      );

      const results = await Promise.all(promises);
      const endTime = performance.now();
      const duration = endTime - startTime;

      // Should handle concurrent requests efficiently
      expect(duration).toBeLessThan(3000); // Under 3 seconds for 10 concurrent requests
      expect(results).toHaveLength(10);
      results.forEach((result) => {
        expect(result).toBeDefined();
        expect(result.recommendations.length).toBeGreaterThan(0);
      });

      console.log(`10 concurrent recommendations generated in ${duration.toFixed(2)}ms`);
    });

    it('should handle mixed operations concurrently', async () => {
      // Setup mocks
      (supabase.from as jest.Mock).mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            data: [{ id: 'item-1', category: 'tops' }],
            error: null,
          }),
        }),
        insert: jest.fn().mockReturnValue({
          data: { id: 'mixed-operation' },
          error: null,
        }),
        update: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            data: {},
            error: null,
          }),
        }),
      });

      (weatherService.getCurrentWeather as jest.Mock).mockResolvedValue({
        temperature: 18,
        condition: 'cloudy' as const,
        humidity: 65,
        location: 'Mixed City',
        timestamp: mockDate,
      });

      const startTime = performance.now();

      // Execute mixed operations concurrently
      const operations = await Promise.all([
        aynaMirrorService.generateDailyRecommendations('user-1'),
        aynaMirrorService.processUserFeedback({
          id: 'fb-1',
          outfitRecommendationId: 'outfit-1',
          userId: 'user-2',
          confidenceRating: 4,
          emotionalResponse: {
            primary: 'confident',
            intensity: 8,
            additionalEmotions: [],
            timestamp: new Date(),
          },
          comfort: { physical: 4, emotional: 4, confidence: 4 },
          timestamp: mockDate,
        }),
        intelligenceService.analyzeUserStyleProfile('user-3'),
        enhancedWardrobeService.trackItemUsage('item-1', 'outfit-1'),
        notificationService.scheduleDailyMirrorNotification('user-4', {
          preferredTime: new Date(),
          timezone: 'UTC',
          enableWeekends: true,
          enableQuickOptions: true,
          confidenceNoteStyle: 'encouraging',
        }),
      ]);

      const endTime = performance.now();
      const duration = endTime - startTime;

      expect(duration).toBeLessThan(1500); // Under 1.5 seconds for mixed operations
      expect(operations).toHaveLength(5);
      console.log(`Mixed concurrent operations completed in ${duration.toFixed(2)}ms`);
    });
  });

  describe('Memory and Resource Usage', () => {
    it('should not leak memory during repeated operations', async () => {
      // Setup mocks
      (supabase.from as jest.Mock).mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            data: [{ id: 'memory-test-item', category: 'tops' }],
            error: null,
          }),
        }),
        insert: jest.fn().mockReturnValue({
          data: { id: 'memory-test-recommendation' },
          error: null,
        }),
      });

      (weatherService.getCurrentWeather as jest.Mock).mockResolvedValue({
        temperature: 22,
        condition: 'sunny' as const,
        humidity: 40,
        location: 'Memory Test City',
        timestamp: mockDate,
      });

      // Measure initial memory usage (if available)
      const initialMemory = process.memoryUsage?.() || { heapUsed: 0 };

      // Perform repeated operations
      for (let i = 0; i < 50; i++) {
        await aynaMirrorService.generateDailyRecommendations(`memory-test-user-${i}`);
      }

      // Measure final memory usage
      const finalMemory = process.memoryUsage?.() || { heapUsed: 0 };
      const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed;

      // Memory increase should be reasonable (less than 50MB for 50 operations)
      expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024);
      console.log(
        `Memory increase after 50 operations: ${(memoryIncrease / 1024 / 1024).toFixed(2)}MB`,
      );
    });

    it('should handle timeout scenarios gracefully', async () => {
      // Mock slow external service
      (weatherService.getCurrentWeather as jest.Mock).mockImplementation(
        () =>
          new Promise((resolve) =>
            setTimeout(
              () =>
                resolve({
                  temperature: 20,
                  condition: 'cloudy' as const,
                  humidity: 60,
                  location: 'Timeout Test',
                  timestamp: mockDate,
                }),
              2000,
            ),
          ), // 2 second delay
      );

      (supabase.from as jest.Mock).mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            data: [{ id: 'timeout-item', category: 'tops' }],
            error: null,
          }),
        }),
        insert: jest.fn().mockReturnValue({
          data: { id: 'timeout-recommendation' },
          error: null,
        }),
      });

      const startTime = performance.now();

      // Should still complete even with slow external service
      const recommendations =
        await aynaMirrorService.generateDailyRecommendations('timeout-test-user');

      const endTime = performance.now();
      const duration = endTime - startTime;

      // Should handle timeout gracefully and still provide recommendations
      expect(recommendations).toBeDefined();
      expect(duration).toBeLessThan(5000); // Should not hang indefinitely
      console.log(`Timeout scenario handled in ${duration.toFixed(2)}ms`);
    });
  });

  describe('Database Query Performance', () => {
    it('should optimize wardrobe queries for large datasets', async () => {
      // Simulate database query timing
      let queryCount = 0;
      (supabase.from as jest.Mock).mockReturnValue({
        select: jest.fn().mockImplementation(() => {
          queryCount++;
          return {
            eq: jest.fn().mockReturnValue({
              data: Array.from({ length: 100 }, (_, i) => ({
                id: `query-item-${i}`,
                category: 'tops',
              })),
              error: null,
            }),
          };
        }),
        insert: jest.fn().mockReturnValue({
          data: { id: 'query-recommendation' },
          error: null,
        }),
      });

      await aynaMirrorService.generateDailyRecommendations('query-test-user');

      // Should minimize database queries
      expect(queryCount).toBeLessThan(5); // Should not make excessive queries
      console.log(`Database queries executed: ${queryCount}`);
    });
  });
});
